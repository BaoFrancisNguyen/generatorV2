#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PATTERNS Ã‰NERGÃ‰TIQUES - GÃ‰NÃ‰RATEUR MALAYSIA
Fichier: app/utils/energy_patterns.py

GÃ©nÃ©rateur de patterns Ã©nergÃ©tiques rÃ©alistes adaptÃ©s au climat tropical
malaysien avec variations saisonniÃ¨res, journaliÃ¨res et comportementales.

Auteur: Ã‰quipe DÃ©veloppement
Date: 2025
Version: 3.0 - Patterns tropicaux
"""

import logging
import math
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import numpy as np
import pandas as pd


class EnergyPatternGenerator:
    """
    GÃ©nÃ©rateur de patterns Ã©nergÃ©tiques adaptÃ© au contexte malaysien.
    
    Prend en compte:
    - Climat tropical avec saisons de mousson
    - Habitudes culturelles malaysiennes
    - Variations urbaines vs rurales
    - Types de bÃ¢timents spÃ©cifiques
    """
    
    def __init__(self):
        """Initialise le gÃ©nÃ©rateur de patterns Ã©nergÃ©tiques."""
        self.logger = logging.getLogger(__name__)
        
        # Patterns de base par type de bÃ¢timent
        self.base_patterns = self._load_base_patterns()
        
        # Variations saisonniÃ¨res Malaysia
        self.seasonal_variations = self._load_seasonal_variations()
        
        # Patterns journaliers par type
        self.daily_patterns = self._load_daily_patterns()
        
        # Facteurs de randomisation
        self.noise_levels = {
            'residential': 0.15,  # 15% de variation alÃ©atoire
            'commercial': 0.10,   # 10% de variation
            'industrial': 0.08,   # 8% de variation (plus prÃ©visible)
            'public': 0.12        # 12% de variation
        }
        
        self.logger.info("âœ… GÃ©nÃ©rateur de patterns Ã©nergÃ©tiques initialisÃ©")
    
    def _load_base_patterns(self) -> Dict[str, Dict]:
        """Charge les patterns Ã©nergÃ©tiques de base par type de bÃ¢timent."""
        
        return {
            'residential': {
                'base_consumption_kwh': 25.0,
                'peak_hours': [7, 8, 19, 20, 21],  # Matin et soirÃ©e
                'low_hours': [1, 2, 3, 4, 5],      # Nuit profonde
                'ac_dependency': 0.6,               # 60% de la consommation pour AC
                'seasonal_sensitivity': 0.4,       # Sensible aux saisons
                'weekend_factor': 1.2,              # +20% le weekend
                'ramadan_factor': 0.85              # -15% pendant Ramadan
            },
            'commercial': {
                'base_consumption_kwh': 120.0,
                'peak_hours': [9, 10, 11, 14, 15, 16],  # Heures de bureau
                'low_hours': [22, 23, 0, 1, 2, 3, 4, 5, 6],  # Nuit
                'ac_dependency': 0.75,              # AC trÃ¨s important
                'seasonal_sensitivity': 0.5,       # TrÃ¨s sensible aux saisons
                'weekend_factor': 0.3,              # 70% de rÃ©duction le weekend
                'ramadan_factor': 0.7               # -30% pendant Ramadan (horaires rÃ©duits)
            },
            'industrial': {
                'base_consumption_kwh': 400.0,
                'peak_hours': [8, 9, 10, 11, 13, 14, 15, 16],  # Horaires de travail
                'low_hours': [22, 23, 0, 1, 2, 3, 4, 5],
                'ac_dependency': 0.25,              # AC moins important
                'seasonal_sensitivity': 0.2,       # Moins sensible aux saisons
                'weekend_factor': 0.8,              # Fonctionnement rÃ©duit le weekend
                'ramadan_factor': 0.9               # LÃ©gÃ¨re rÃ©duction pendant Ramadan
            },
            'public': {
                'base_consumption_kwh': 80.0,
                'peak_hours': [8, 9, 10, 11, 13, 14, 15, 16, 17],  # Heures de service
                'low_hours': [20, 21, 22, 23, 0, 1, 2, 3, 4, 5],
                'ac_dependency': 0.65,              # AC important pour le confort public
                'seasonal_sensitivity': 0.35,      # ModÃ©rÃ©ment sensible
                'weekend_factor': 0.6,              # Service rÃ©duit le weekend
                'ramadan_factor': 0.8               # Horaires rÃ©duits pendant Ramadan
            }
        }
    
    def _load_seasonal_variations(self) -> Dict[str, float]:
        """Charge les variations saisonniÃ¨res pour Malaysia."""
        
        # BasÃ© sur le climat tropical malaysien
        return {
            1: 0.85,   # Janvier - Mousson du nord-est (plus frais)
            2: 0.90,   # FÃ©vrier - Fin de mousson
            3: 1.15,   # Mars - Inter-mousson (chaud et humide)
            4: 1.25,   # Avril - TrÃ¨s chaud
            5: 1.20,   # Mai - TrÃ¨s chaud
            6: 1.00,   # Juin - Mousson du sud-ouest commence
            7: 0.95,   # Juillet - Mousson (plus frais)
            8: 0.95,   # AoÃ»t - Mousson
            9: 1.10,   # Septembre - Inter-mousson
            10: 1.15,  # Octobre - Chaud et humide
            11: 0.95,  # Novembre - DÃ©but mousson nord-est
            12: 0.85   # DÃ©cembre - Mousson (plus frais)
        }
    
    def _load_daily_patterns(self) -> Dict[str, List[float]]:
        """Charge les patterns journaliers par type de bÃ¢timent (24 heures)."""
        
        return {
            'residential': [
                # Profil rÃ©sidentiel malaysien typique
                0.3, 0.2, 0.2, 0.2, 0.2, 0.3,  # 00-05: Nuit (AC en veille)
                0.6, 0.9, 0.7, 0.5, 0.4, 0.4,  # 06-11: Matin (prÃ©paration, dÃ©part)
                0.4, 0.4, 0.4, 0.4, 0.5, 0.6,  # 12-17: JournÃ©e (maison vide)
                0.8, 1.0, 1.0, 0.9, 0.7, 0.5   # 18-23: SoirÃ©e (retour, AC plein)
            ],
            'commercial': [
                # Profil commercial (bureaux, magasins)
                0.1, 0.1, 0.1, 0.1, 0.1, 0.2,  # 00-05: FermÃ©
                0.3, 0.4, 0.6, 1.0, 1.0, 0.9,  # 06-11: Ouverture, pic matinal
                0.8, 0.9, 1.0, 1.0, 0.9, 0.8,  # 12-17: ActivitÃ© de jour
                0.6, 0.4, 0.3, 0.2, 0.1, 0.1   # 18-23: Fermeture progressive
            ],
            'industrial': [
                # Profil industriel (2-3 shifts)
                0.6, 0.6, 0.5, 0.5, 0.5, 0.6,  # 00-05: Shift de nuit
                0.7, 0.8, 1.0, 1.0, 1.0, 0.9,  # 06-11: Shift du matin
                0.8, 0.9, 1.0, 1.0, 0.9, 0.8,  # 12-17: Shift d'aprÃ¨s-midi
                0.7, 0.7, 0.6, 0.6, 0.6, 0.6   # 18-23: Shift du soir
            ],
            'public': [
                # Profil service public (hÃ´pitaux, Ã©coles, bureaux gov)
                0.2, 0.2, 0.2, 0.2, 0.2, 0.3,  # 00-05: Service minimal
                0.4, 0.6, 0.8, 1.0, 1.0, 0.9,  # 06-11: Ouverture service
                0.8, 0.9, 1.0, 1.0, 0.9, 0.7,  # 12-17: Pleine activitÃ©
                0.5, 0.4, 0.3, 0.3, 0.2, 0.2   # 18-23: Fermeture progressive
            ]
        }
    
    def generate_consumption_pattern(self, building_type: str, location: str,
                                   date_range: pd.DatetimeIndex, frequency: str,
                                   characteristics: Dict = None) -> np.ndarray:
        """
        GÃ©nÃ¨re un pattern de consommation rÃ©aliste pour un bÃ¢timent.
        
        Args:
            building_type: Type de bÃ¢timent
            location: Nom de la localisation
            date_range: Plage temporelle
            frequency: FrÃ©quence des donnÃ©es
            characteristics: CaractÃ©ristiques du bÃ¢timent
            
        Returns:
            Array des valeurs de consommation
        """
        self.logger.debug(f"ğŸ”‹ GÃ©nÃ©ration pattern {building_type} Ã  {location}")
        
        if building_type not in self.base_patterns:
            building_type = 'residential'  # Fallback
        
        base_pattern = self.base_patterns[building_type]
        daily_pattern = self.daily_patterns[building_type]
        
        # CaractÃ©ristiques par dÃ©faut
        if characteristics is None:
            characteristics = {}
        
        consumption_values = []
        
        for timestamp in date_range:
            # Consommation de base
            base_consumption = base_pattern['base_consumption_kwh']
            
            # Facteur journalier (selon l'heure)
            hour = timestamp.hour
            daily_factor = daily_pattern[hour]
            
            # Facteur saisonnier (selon le mois)
            month = timestamp.month
            seasonal_factor = self.seasonal_variations[month]
            
            # Facteur weekend
            is_weekend = timestamp.weekday() >= 5
            weekend_factor = base_pattern['weekend_factor'] if is_weekend else 1.0
            
            # Facteur climatique (tempÃ©rature et humiditÃ© estimÃ©es)
            climate_factor = self._calculate_climate_factor(timestamp, location, base_pattern)
            
            # Facteurs spÃ©ciaux (Ramadan, jours fÃ©riÃ©s, etc.)
            special_factor = self._calculate_special_factors(timestamp, building_type)
            
            # Facteurs spÃ©cifiques au bÃ¢timent
            building_factor = self._calculate_building_factors(characteristics, building_type)
            
            # Calcul de la consommation
            consumption = (base_consumption * 
                          daily_factor * 
                          seasonal_factor * 
                          weekend_factor * 
                          climate_factor * 
                          special_factor * 
                          building_factor)
            
            # Ajouter du bruit rÃ©aliste
            noise_level = self.noise_levels.get(building_type, 0.1)
            noise = np.random.normal(1.0, noise_level)
            consumption *= max(0.1, noise)  # Ã‰viter les valeurs nÃ©gatives
            
            consumption_values.append(max(0.0, consumption))
        
        return np.array(consumption_values)
    
    def _calculate_climate_factor(self, timestamp: datetime, location: str, 
                                base_pattern: Dict) -> float:
        """
        Calcule le facteur climatique basÃ© sur la tempÃ©rature estimÃ©e.
        
        Args:
            timestamp: Moment de l'observation
            location: Localisation
            base_pattern: Pattern de base du bÃ¢timent
            
        Returns:
            Facteur climatique (multiplicateur)
        """
        # TempÃ©rature estimÃ©e pour Malaysia (modÃ¨le simplifiÃ©)
        month = timestamp.month
        hour = timestamp.hour
        
        # TempÃ©rature de base selon le mois (Â°C)
        base_temps = {
            1: 26, 2: 27, 3: 29, 4: 30, 5: 30, 6: 29,
            7: 28, 8: 28, 9: 29, 10: 29, 11: 28, 12: 26
        }
        
        base_temp = base_temps[month]
        
        # Variation journaliÃ¨re (-3Â°C la nuit, +3Â°C l'aprÃ¨s-midi)
        if 6 <= hour <= 8:
            temp_variation = -1  # Matin frais
        elif 14 <= hour <= 16:
            temp_variation = 3   # AprÃ¨s-midi chaud
        elif 22 <= hour or hour <= 5:
            temp_variation = -3  # Nuit fraÃ®che
        else:
            temp_variation = 0
        
        estimated_temp = base_temp + temp_variation
        
        # Facteur de climatisation selon la tempÃ©rature
        ac_dependency = base_pattern['ac_dependency']
        
        if estimated_temp >= 30:
            # TrÃ¨s chaud - AC Ã  fond
            climate_factor = 1.0 + (estimated_temp - 30) * ac_dependency * 0.05
        elif estimated_temp >= 27:
            # Chaud - AC normal
            climate_factor = 1.0 + (estimated_temp - 27) * ac_dependency * 0.03
        elif estimated_temp >= 24:
            # TempÃ©rÃ© - AC modÃ©rÃ©
            climate_factor = 1.0
        else:
            # Frais - AC rÃ©duit
            climate_factor = 1.0 - (24 - estimated_temp) * ac_dependency * 0.02
        
        return max(0.5, climate_factor)  # Minimum 50% de la consommation
    
    def _calculate_special_factors(self, timestamp: datetime, building_type: str) -> float:
        """
        Calcule les facteurs spÃ©ciaux (Ramadan, jours fÃ©riÃ©s, etc.).
        
        Args:
            timestamp: Moment de l'observation
            building_type: Type de bÃ¢timent
            
        Returns:
            Facteur spÃ©cial (multiplicateur)
        """
        base_pattern = self.base_patterns[building_type]
        special_factor = 1.0
        
        # Approximation Ramadan (se dÃ©place chaque annÃ©e)
        # Pour simplicitÃ©, on utilise une pÃ©riode fixe approximative
        if self._is_approximate_ramadan(timestamp):
            special_factor *= base_pattern['ramadan_factor']
        
        # Jours fÃ©riÃ©s malaysiens approximatifs
        if self._is_public_holiday(timestamp):
            if building_type == 'commercial':
                special_factor *= 0.2  # Magasins fermÃ©s
            elif building_type == 'public':
                special_factor *= 0.3  # Services rÃ©duits
            elif building_type == 'residential':
                special_factor *= 1.1  # Plus Ã  la maison
        
        return special_factor
    
    def _calculate_building_factors(self, characteristics: Dict, building_type: str) -> float:
        """
        Calcule les facteurs spÃ©cifiques au bÃ¢timent.
        
        Args:
            characteristics: CaractÃ©ristiques du bÃ¢timent
            building_type: Type de bÃ¢timent
            
        Returns:
            Facteur du bÃ¢timent (multiplicateur)
        """
        factor = 1.0
        
        # Facteur selon la surface
        if 'floor_area_sqm' in characteristics:
            area = characteristics['floor_area_sqm']
            if building_type == 'commercial':
                # Plus grand magasin = plus de consommation
                if area > 1000:
                    factor *= 1.3
                elif area < 100:
                    factor *= 0.7
            elif building_type == 'residential':
                # Plus grande maison = plus de consommation
                if area > 200:
                    factor *= 1.2
                elif area < 50:
                    factor *= 0.8
        
        # Facteur selon l'Ã¢ge du bÃ¢timent
        if 'building_age' in characteristics:
            age = characteristics['building_age']
            if age > 20:
                factor *= 1.15  # BÃ¢timents anciens moins efficaces
            elif age < 5:
                factor *= 0.9   # BÃ¢timents rÃ©cents plus efficaces
        
        # Facteur selon l'efficacitÃ© Ã©nergÃ©tique
        if 'energy_efficiency' in characteristics:
            efficiency = characteristics['energy_efficiency']
            # efficiency entre 0.5 (inefficace) et 1.5 (trÃ¨s efficace)
            factor *= (2.0 - efficiency)
        
        # Facteur selon le nombre d'occupants (rÃ©sidentiel)
        if building_type == 'residential' and 'avg_occupancy' in characteristics:
            occupancy = characteristics['avg_occupancy']
            # Plus d'occupants = plus de consommation
            factor *= (0.7 + occupancy * 0.1)
        
        # Facteur selon l'activitÃ© (commercial/industriel)
        if 'operating_hours' in characteristics:
            hours = characteristics['operating_hours']
            if hours > 12:
                factor *= 1.2  # Longues heures d'opÃ©ration
            elif hours < 8:
                factor *= 0.8  # Heures rÃ©duites
        
        return max(0.3, factor)  # Minimum 30% de la consommation de base
    
    def _is_approximate_ramadan(self, timestamp: datetime) -> bool:
        """VÃ©rifie si la date est approximativement pendant Ramadan."""
        # Approximation trÃ¨s simplifiÃ©e du Ramadan
        # En rÃ©alitÃ©, Ramadan se dÃ©cale de ~11 jours chaque annÃ©e
        year = timestamp.year
        
        # Dates approximatives de Ramadan pour diffÃ©rentes annÃ©es
        ramadan_periods = {
            2024: (datetime(2024, 3, 10), datetime(2024, 4, 9)),
            2025: (datetime(2025, 2, 28), datetime(2025, 3, 30)),
            2026: (datetime(2026, 2, 17), datetime(2026, 3, 19)),
        }
        
        if year in ramadan_periods:
            start, end = ramadan_periods[year]
            return start <= timestamp <= end
        
        return False
    
    def _is_public_holiday(self, timestamp: datetime) -> bool:
        """VÃ©rifie si c'est un jour fÃ©riÃ© malaysien approximatif."""
        month = timestamp.month
        day = timestamp.day
        
        # Jours fÃ©riÃ©s fixes approximatifs
        fixed_holidays = [
            (1, 1),   # Nouvel An
            (2, 1),   # FÃªte FÃ©dÃ©rale
            (5, 1),   # FÃªte du Travail
            (6, 5),   # Anniversaire du Roi (approximatif)
            (8, 31),  # FÃªte Nationale
            (9, 16),  # Jour de la Malaysia
            (12, 25), # NoÃ«l
        ]
        
        return (month, day) in fixed_holidays
    
    def generate_weather_context(self, timestamp: datetime, location: str) -> Dict[str, Any]:
        """
        GÃ©nÃ¨re un contexte mÃ©tÃ©orologique approximatif.
        
        Args:
            timestamp: Moment de l'observation
            location: Localisation
            
        Returns:
            Contexte mÃ©tÃ©orologique
        """
        month = timestamp.month
        hour = timestamp.hour
        
        # TempÃ©rature de base selon le mois
        base_temps = {
            1: 26, 2: 27, 3: 29, 4: 30, 5: 30, 6: 29,
            7: 28, 8: 28, 9: 29, 10: 29, 11: 28, 12: 26
        }
        
        base_temp = base_temps[month]
        
        # Variation journaliÃ¨re
        if 6 <= hour <= 8:
            temp_variation = -1
        elif 14 <= hour <= 16:
            temp_variation = 3
        elif 22 <= hour or hour <= 5:
            temp_variation = -3
        else:
            temp_variation = 0
        
        temperature = base_temp + temp_variation + np.random.normal(0, 1)
        
        # HumiditÃ© (toujours Ã©levÃ©e en Malaysia)
        base_humidity = 80
        humidity_variation = np.random.normal(0, 5)
        humidity = max(60, min(95, base_humidity + humidity_variation))
        
        # ProbabilitÃ© de pluie selon la saison
        rain_probabilities = {
            1: 0.4, 2: 0.3, 3: 0.2, 4: 0.3, 5: 0.3, 6: 0.5,
            7: 0.5, 8: 0.5, 9: 0.4, 10: 0.4, 11: 0.6, 12: 0.5
        }
        
        is_raining = np.random.random() < rain_probabilities[month]
        
        return {
            'temperature': round(temperature, 1),
            'humidity': round(humidity, 1),
            'is_raining': is_raining,
            'season': self._get_season(month),
            'heat_index': round(temperature + (humidity - 40) * 0.1, 1)
        }
    
    def _get_season(self, month: int) -> str:
        """Retourne la saison malaysienne selon le mois."""
        if month in [11, 12, 1, 2]:
            return 'northeast_monsoon'
        elif month in [6, 7, 8]:
            return 'southwest_monsoon'
        else:
            return 'inter_monsoon'
    
    def get_pattern_statistics(self, building_type: str) -> Dict[str, Any]:
        """
        Retourne les statistiques des patterns pour un type de bÃ¢timent.
        
        Args:
            building_type: Type de bÃ¢timent
            
        Returns:
            Statistiques des patterns
        """
        if building_type not in self.base_patterns:
            return {}
        
        base_pattern = self.base_patterns[building_type]
        daily_pattern = self.daily_patterns[building_type]
        
        return {
            'base_consumption_kwh': base_pattern['base_consumption_kwh'],
            'peak_hours': base_pattern['peak_hours'],
            'low_hours': base_pattern['low_hours'],
            'daily_pattern_peak': max(daily_pattern),
            'daily_pattern_min': min(daily_pattern),
            'daily_pattern_avg': np.mean(daily_pattern),
            'seasonal_variation_range': {
                'min': min(self.seasonal_variations.values()),
                'max': max(self.seasonal_variations.values())
            },
            'ac_dependency': base_pattern['ac_dependency'],
            'noise_level': self.noise_levels.get(building_type, 0.1)
        }


# Export de la classe principale
__all__ = ['EnergyPatternGenerator']